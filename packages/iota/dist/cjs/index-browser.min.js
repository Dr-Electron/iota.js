!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@iota/crypto.js"),require("big-integer"),require("@iota/util.js")):"function"==typeof define&&define.amd?define(["exports","@iota/crypto.js","big-integer","@iota/util.js"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Iota={},e.IotaCrypto,e.bigInt,e.IotaUtil)}(this,(function(e,t,n,i){"use strict";function o(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var r=o(n);class s{constructor(e){this._publicKey=e}toAddress(){return t.Blake2b.sum256(this._publicKey)}verify(e){return t.ArrayHelper.equal(this.toAddress(),e)}}s.ADDRESS_LENGTH=t.Blake2b.SIZE_256;const a=16,d=t.Blake2b.SIZE_256,u=t.Blake2b.SIZE_256,l=t.Blake2b.SIZE_256;function c(e){if(!e.hasRemaining(21))throw new Error(`Alias address data is ${e.length()} in length which is less than the minimimum size required of 21`);const t=e.readUInt8("aliasAddress.type");if(8!==t)throw new Error(`Type mismatch in aliasAddress ${t}`);return{type:8,address:e.readFixedHex("aliasAddress.address",20)}}function h(e,t){e.writeUInt8("aliasAddress.type",t.type),e.writeFixedHex("aliasAddress.address",20,t.address)}function p(e){if(!e.hasRemaining(33))throw new Error(`BLS address data is ${e.length()} in length which is less than the minimimum size required of 33`);const t=e.readUInt8("blsAddress.type");if(1!==t)throw new Error(`Type mismatch in blsAddress ${t}`);return{type:1,address:e.readFixedHex("blsAddress.address",32)}}function f(e,t){e.writeUInt8("blsAddress.type",t.type),e.writeFixedHex("blsAddress.address",32,t.address)}const m=1+s.ADDRESS_LENGTH;function g(e){if(!e.hasRemaining(m))throw new Error(`Ed25519 address data is ${e.length()} in length which is less than the minimimum size required of ${m}`);const t=e.readUInt8("ed25519Address.type");if(0!==t)throw new Error(`Type mismatch in ed25519Address ${t}`);return{type:0,address:e.readFixedHex("ed25519Address.address",s.ADDRESS_LENGTH)}}function y(e,t){e.writeUInt8("ed25519Address.type",t.type),e.writeFixedHex("ed25519Address.address",s.ADDRESS_LENGTH,t.address)}function T(e){if(!e.hasRemaining(21))throw new Error(`NFT address data is ${e.length()} in length which is less than the minimimum size required of 21`);const t=e.readUInt8("nftAddress.type");if(t!==a)throw new Error(`Type mismatch in nftAddress ${t}`);const n=e.readFixedHex("nftAddress.address",20);return{type:a,address:n}}function I(e,t){e.writeUInt8("nftAddress.type",t.type),e.writeFixedHex("nftAddress.address",20,t.address)}const w=Math.min(m,21,33,21);function E(e){if(!e.hasRemaining(w))throw new Error(`Address data is ${e.length()} in length which is less than the minimimum size required of ${w}`);const t=e.readUInt8("address.type",!1);let n;if(0===t)n=g(e);else if(8===t)n=c(e);else if(1===t)n=p(e);else{if(t!==a)throw new Error(`Unrecognized address type ${t}`);n=T(e)}return n}function U(e,t){if(0===t.type)y(e,t);else if(8===t.type)h(e,t);else if(1===t.type)f(e,t);else{if(t.type!==a)throw new Error(`Unrecognized address type ${t.type}`);I(e,t)}}const _=1+w;function k(e){if(!e.hasRemaining(_))throw new Error(`Issuer Feature Block data is ${e.length()} in length which is less than the minimimum size required of ${_}`);const t=e.readUInt8("issuerFeatureBlock.type");if(1!==t)throw new Error(`Type mismatch in issuerFeatureBlock ${t}`);return{type:1,address:E(e)}}function $(e,t){e.writeUInt8("issuerFeatureBlock.type",t.type),U(e,t.address)}function N(e){if(!e.hasRemaining(5))throw new Error(`Metadata Feature Block data is ${e.length()} in length which is less than the minimimum size required of 5`);const t=e.readUInt8("metadataFeatureBlock.type");if(2!==t)throw new Error(`Type mismatch in metadataFeatureBlock ${t}`);const n=e.readUInt32("metadataFeatureBlock.dataLength");return{type:2,data:e.readFixedHex("metadataFeatureBlock.data",n)}}function A(e,t){e.writeUInt8("metadataFeatureBlock.type",t.type),e.writeUInt32("metadataFeatureBlock.dataLength",t.data.length/2),e.writeFixedHex("metadataFeatureBlock.data",t.data.length/2,t.data)}const x=1+w;function v(e){if(!e.hasRemaining(x))throw new Error(`Sender Feature Block data is ${e.length()} in length which is less than the minimimum size required of ${x}`);const t=e.readUInt8("senderFeatureBlock.type");if(0!==t)throw new Error(`Type mismatch in senderFeatureBlock ${t}`);return{type:0,address:E(e)}}function S(e,t){e.writeUInt8("senderFeatureBlock.type",t.type),U(e,t.address)}function C(e){if(!e.hasRemaining(2))throw new Error(`Tag Feature Block data is ${e.length()} in length which is less than the minimimum size required of 2`);const t=e.readUInt8("tagFeatureBlock.type");if(3!==t)throw new Error(`Type mismatch in tagFeatureBlock ${t}`);const n=e.readUInt8("tagFeatureBlock.tagLength");return{type:3,tag:e.readFixedHex("tagFeatureBlock.tag",n)}}function B(e,t){e.writeUInt8("tagFeatureBlock.type",t.type),e.writeUInt8("tagFeatureBlock.tagLength",t.tag.length/2),e.writeFixedHex("tagFeatureBlock.tag",t.tag.length/2,t.tag)}const M=Math.min(x,_,5,2);function P(e){const t=e.readUInt8("featureBlocks.numFeatureBlocks"),n=[];for(let i=0;i<t;i++)n.push(R(e));return n}function O(e,t){e.writeUInt8("featureBlocks.numFeatureBlocks",t.length);for(let n=0;n<t.length;n++)z(e,t[n])}function R(e){if(!e.hasRemaining(M))throw new Error(`Feature block data is ${e.length()} in length which is less than the minimimum size required of ${M}`);const t=e.readUInt8("featureBlock.type",!1);let n;if(0===t)n=v(e);else if(1===t)n=k(e);else if(2===t)n=N(e);else{if(3!==t)throw new Error(`Unrecognized feature block type ${t}`);n=C(e)}return n}function z(e,t){if(0===t.type)S(e,t);else if(1===t.type)$(e,t);else if(2===t.type)A(e,t);else{if(3!==t.type)throw new Error(`Unrecognized feature block type ${t.type}`);B(e,t)}}const H=49+w+8;function b(e){const t=e.readUInt16("funds.numFunds"),n=[];for(let i=0;i<t;i++)n.push(F(e));return n}function L(e,t){if(t.length>127)throw new Error(`The maximum number of funds is 127, you have provided ${t.length}`);e.writeUInt16("funds.numFunds",t.length);for(let n=0;n<t.length;n++)D(e,t[n])}function F(e){if(!e.hasRemaining(H))throw new Error(`Migrated funds data is ${e.length()} in length which is less than the minimimum size required of ${H}`);const t=e.readFixedHex("migratedFunds.tailTransactionHash",49),n=E(e),i=e.readUInt64("migratedFunds.deposit");return{tailTransactionHash:t,address:n,deposit:Number(i)}}function D(e,t){e.writeFixedHex("migratedFunds.tailTransactionHash",49,t.tailTransactionHash),U(e,t.address),e.writeUInt64("migratedFunds.deposit",r.default(t.deposit))}const G=1+u;function K(e){if(!e.hasRemaining(G))throw new Error(`Treasury Input data is ${e.length()} in length which is less than the minimimum size required of ${G}`);const t=e.readUInt8("treasuryInput.type");if(1!==t)throw new Error(`Type mismatch in treasuryInput ${t}`);return{type:1,milestoneId:e.readFixedHex("treasuryInput.milestoneId",u)}}function Y(e,t){e.writeUInt8("treasuryInput.type",t.type),e.writeFixedHex("treasuryInput.milestoneId",u,t.milestoneId)}const q=1+u+2;function W(e){if(!e.hasRemaining(q))throw new Error(`UTXO Input data is ${e.length()} in length which is less than the minimimum size required of ${q}`);const t=e.readUInt8("utxoInput.type");if(0!==t)throw new Error(`Type mismatch in utxoInput ${t}`);return{type:0,transactionId:e.readFixedHex("utxoInput.transactionId",u),transactionOutputIndex:e.readUInt16("utxoInput.transactionOutputIndex")}}function Z(e,t){e.writeUInt8("utxoInput.type",t.type),e.writeFixedHex("utxoInput.transactionId",u,t.transactionId),e.writeUInt16("utxoInput.transactionOutputIndex",t.transactionOutputIndex)}const V=Math.min(q,G);function X(e){const t=e.readUInt16("inputs.numInputs"),n=[];for(let i=0;i<t;i++)n.push(j(e));return n}function J(e,t){if(t.length<1)throw new Error(`The minimum number of inputs is 1, you have provided ${t.length}`);if(t.length>128)throw new Error(`The maximum number of inputs is 128, you have provided ${t.length}`);e.writeUInt16("inputs.numInputs",t.length);for(let n=0;n<t.length;n++)Q(e,t[n])}function j(e){if(!e.hasRemaining(V))throw new Error(`Input data is ${e.length()} in length which is less than the minimimum size required of ${V}`);const t=e.readUInt8("input.type",!1);let n;if(0===t)n=W(e);else{if(1!==t)throw new Error(`Unrecognized input type ${t}`);n=K(e)}return n}function Q(e,t){if(0===t.type)Z(e,t);else{if(1!==t.type)throw new Error(`Unrecognized input type ${t.type}`);Y(e,t)}}const ee=16+d+d+l+8+1+t.Ed25519.PUBLIC_KEY_SIZE+1+t.Ed25519.SIGNATURE_SIZE;const te=10+H;const ne=64;const ie=t.Blake2b.SIZE_256;function oe(e){const t=e.readUInt8("nativeTokens.numNativeTokens"),n=[];for(let i=0;i<t;i++)n.push(se(e));return n}function re(e,t){e.writeUInt8("nativeTokens.numNativeTokens",t.length);for(let n=0;n<t.length;n++)ae(e,t[n])}function se(e){return{id:e.readFixedHex("nativeToken.id",38),amount:e.readUInt256("nativeToken.amount").toString()}}function ae(e,t){e.writeFixedHex("nativeToken.id",38,t.id),e.writeUInt256("nativeToken.amount",r.default(t.amount))}const de=1+w;function ue(e){if(!e.hasRemaining(de))throw new Error(`Address unlock condition data is ${e.length()} in length which is less than the minimimum size required of ${de}`);const t=e.readUInt8("addressUnlockCondition.type");if(0!==t)throw new Error(`Type mismatch in addressUnlockCondition ${t}`);return{type:0,address:E(e)}}function le(e,t){e.writeUInt8("addressUnlockCondition.type",t.type),U(e,t.address)}const ce=1+w+8;function he(e){if(!e.hasRemaining(ce))throw new Error(`Dust deposit return unlock condition data is ${e.length()} in length which is less than the minimimum size required of ${ce}`);const t=e.readUInt8("dustDepositReturnUnlockCondition.type");if(1!==t)throw new Error(`Type mismatch in dustDepositReturnUnlockCondition ${t}`);const n=E(e),i=e.readUInt64("dustDepositReturnUnlockCondition.amount");return{type:1,returnAddress:n,amount:Number(i)}}function pe(e,t){e.writeUInt8("dustDepositReturnUnlockCondition.type",t.type),U(e,t.returnAddress),e.writeUInt64("dustDepositReturnUnlockCondition.amount",r.default(t.amount))}const fe=1+w+4+4;function me(e){if(!e.hasRemaining(fe))throw new Error(`Expiration unlock condition data is ${e.length()} in length which is less than the minimimum size required of ${fe}`);const t=e.readUInt8("expirationUnlockCondition.type");if(3!==t)throw new Error(`Type mismatch in expirationUnlockCondition ${t}`);return{type:3,returnAddress:E(e),milestoneIndex:e.readUInt32("expirationUnlockCondition.milestoneIndex"),unixTime:e.readUInt32("expirationUnlockCondition.unixTime")}}function ge(e,t){e.writeUInt8("expirationUnlockCondition.type",t.type),U(e,t.returnAddress),e.writeUInt32("expirationUnlockCondition.milestoneIndex",t.milestoneIndex),e.writeUInt32("expirationUnlockCondition.unixTime",t.unixTime)}const ye=1+w;function Te(e){if(!e.hasRemaining(ye))throw new Error(`Immutable Alias unlock condition data is ${e.length()} in length which is less than the minimimum size required of ${ye}`);const t=e.readUInt8("immutableAliasUnlockCondition.type");if(6!==t)throw new Error(`Type mismatch in immutableAliasUnlockCondition ${t}`);return{type:6,address:E(e)}}function Ie(e,t){e.writeUInt8("immutableAliasUnlockCondition.type",t.type),U(e,t.address)}function we(e){if(!e.hasRemaining(9))throw new Error(`Timelock unlock condition data is ${e.length()} in length which is less than the minimimum size required of 9`);const t=e.readUInt8("timelockUnlockCondition.type");if(2!==t)throw new Error(`Type mismatch in timelockUnlockCondition ${t}`);return{type:2,milestoneIndex:e.readUInt32("timelockUnlockCondition.milestoneIndex"),unixTime:e.readUInt32("timelockUnlockCondition.unixTime")}}function Ee(e,t){e.writeUInt8("timelockUnlockCondition.type",t.type),e.writeUInt32("timelockUnlockCondition.milestoneIndex",t.milestoneIndex),e.writeUInt32("timelockUnlockCondition.unixTime",t.unixTime)}const Ue=1+w;function _e(e){if(!e.hasRemaining(Ue))throw new Error(`Governor unlock condition data is ${e.length()} in length which is less than the minimimum size required of ${Ue}`);const t=e.readUInt8("governorUnlockCondition.type");if(5!==t)throw new Error(`Type mismatch in governorUnlockCondition ${t}`);return{type:5,address:E(e)}}function ke(e,t){e.writeUInt8("governorUnlockCondition.type",t.type),U(e,t.address)}const $e=1+w;function Ne(e){if(!e.hasRemaining($e))throw new Error(`State controller addres unlock condition data is ${e.length()} in length which is less than the minimimum size required of ${$e}`);const t=e.readUInt8("stateControllerAddresUnlockCondition.type");if(4!==t)throw new Error(`Type mismatch in stateControllerAddresUnlockCondition ${t}`);return{type:4,address:E(e)}}function Ae(e,t){e.writeUInt8("stateControllerAddressUnlockCondition.type",t.type),U(e,t.address)}const xe=Math.min(de,ce,9,fe,$e,Ue,ye);function ve(e){const t=e.readUInt8("unlockConditions.numUnlockConditions"),n=[];for(let i=0;i<t;i++)n.push(Ce(e));return n}function Se(e,t){e.writeUInt8("unlockConditions.numUnlockConditions",t.length);for(let n=0;n<t.length;n++)Be(e,t[n])}function Ce(e){if(!e.hasRemaining(xe))throw new Error(`Unlock condition data is ${e.length()} in length which is less than the minimimum size required of ${xe}`);const t=e.readUInt8("unlockCondition.type",!1);let n;if(0===t)n=ue(e);else if(1===t)n=he(e);else if(2===t)n=we(e);else if(3===t)n=me(e);else if(4===t)n=Ne(e);else if(5===t)n=_e(e);else{if(6!==t)throw new Error(`Unrecognized unlock condition type ${t}`);n=Te(e)}return n}function Be(e,t){if(0===t.type)le(e,t);else if(1===t.type)pe(e,t);else if(2===t.type)Ee(e,t);else if(3===t.type)ge(e,t);else if(4===t.type)Ae(e,t);else if(5===t.type)ke(e,t);else{if(6!==t.type)throw new Error(`Unrecognized unlock condition type ${t.type}`);Ie(e,t)}}function Me(e){if(!e.hasRemaining(45))throw new Error(`Alias Output data is ${e.length()} in length which is less than the minimimum size required of 45`);const t=e.readUInt8("aliasOutput.type");if(4!==t)throw new Error(`Type mismatch in aliasOutput ${t}`);const n=e.readUInt64("aliasOutput.amount"),i=oe(e),o=e.readFixedHex("aliasOutput.aliasId",20),r=e.readUInt32("aliasOutput.stateIndex"),s=e.readUInt32("aliasOutput.stateMetadataLength"),a=e.readFixedHex("aliasOutput.stateMetadata",s),d=e.readUInt32("aliasOutput.foundryCounter"),u=ve(e),l=P(e),c=P(e);return{type:4,amount:Number(n),nativeTokens:i,aliasId:o,stateIndex:r,stateMetadata:a,foundryCounter:d,unlockConditions:u,featureBlocks:l,immutableBlocks:c}}function Pe(e,t){e.writeUInt8("aliasOutput.type",t.type),e.writeUInt64("aliasOutput.amount",r.default(t.amount)),re(e,t.nativeTokens),e.writeFixedHex("aliasOutput.aliasId",20,t.aliasId),e.writeUInt32("aliasOutput.stateIndex",t.stateIndex),e.writeUInt32("aliasOutput.stateMetadataLength",t.stateMetadata.length/2),t.stateMetadata.length>0&&e.writeFixedHex("aliasOutput.stateMetadata",t.stateMetadata.length/2,t.stateMetadata),e.writeUInt32("aliasOutput.foundryCounter",t.foundryCounter),Se(e,t.unlockConditions),O(e,t.featureBlocks),O(e,t.immutableBlocks)}function Oe(e){if(!e.hasRemaining(12))throw new Error(`Basic Output data is ${e.length()} in length which is less than the minimimum size required of 12`);const t=e.readUInt8("basicOutput.type");if(3!==t)throw new Error(`Type mismatch in basicOutput ${t}`);const n=e.readUInt64("basicOutput.amount"),i=oe(e),o=ve(e),r=P(e);return{type:3,amount:Number(n),nativeTokens:i,unlockConditions:o,featureBlocks:r}}function Re(e,t){e.writeUInt8("basicOutput.type",t.type),e.writeUInt64("basicOutput.amount",r.default(t.amount)),re(e,t.nativeTokens),Se(e,t.unlockConditions),O(e,t.featureBlocks)}function ze(e){if(!e.hasRemaining(1))throw new Error(`Simple Token Scheme data is ${e.length()} in length which is less than the minimimum size required of 1`);const t=e.readUInt8("simpleTokenScheme.type");if(0!==t)throw new Error(`Type mismatch in simpleTokenScheme ${t}`);return{type:0}}function He(e,t){e.writeUInt8("simpleTokenScheme.type",t.type)}function be(e){if(!e.hasRemaining(1))throw new Error(`Token Scheme data is ${e.length()} in length which is less than the minimimum size required of 1`);const t=e.readUInt8("tokenScheme.type",!1);let n;if(0!==t)throw new Error(`Unrecognized token scheme type ${t}`);return n=ze(e),n}function Le(e,t){if(0!==t.type)throw new Error(`Unrecognized simple token scheme type ${t.type}`);He(e,t)}function Fe(e){if(!e.hasRemaining(94))throw new Error(`Foundry Output data is ${e.length()} in length which is less than the minimimum size required of 94`);const t=e.readUInt8("foundryOutput.type");if(5!==t)throw new Error(`Type mismatch in foundryOutput ${t}`);const n=e.readUInt64("foundryOutput.amount"),i=oe(e),o=e.readUInt32("foundryOutput.serialNumber"),r=e.readFixedHex("foundryOutput.tokenTag",12),s=e.readUInt256("foundryOutput.circulatingSupply"),a=e.readUInt256("foundryOutput.maximumSupply"),d=be(e),u=ve(e),l=P(e),c=P(e);return{type:5,amount:Number(n),nativeTokens:i,serialNumber:o,tokenTag:r,circulatingSupply:s.toString(),maximumSupply:a.toString(),tokenScheme:d,unlockConditions:u,featureBlocks:l,immutableBlocks:c}}function De(e,t){e.writeUInt8("foundryOutput.type",t.type),e.writeUInt64("foundryOutput.amount",r.default(t.amount)),re(e,t.nativeTokens),e.writeUInt32("foundryOutput.serialNumber",t.serialNumber),e.writeFixedHex("foundryOutput.tokenTag",12,t.tokenTag),e.writeUInt256("foundryOutput.circulatingSupply",r.default(t.circulatingSupply)),e.writeUInt256("foundryOutput.maximumSupply",r.default(t.maximumSupply)),Le(e,t.tokenScheme),Se(e,t.unlockConditions),O(e,t.featureBlocks),O(e,t.immutableBlocks)}function Ge(e){if(!e.hasRemaining(33))throw new Error(`NFT Output data is ${e.length()} in length which is less than the minimimum size required of 33`);const t=e.readUInt8("nftOutput.type");if(6!==t)throw new Error(`Type mismatch in nftOutput ${t}`);const n=e.readUInt64("nftOutput.amount"),i=oe(e),o=e.readFixedHex("nftOutput.nftId",20),r=ve(e),s=P(e),a=P(e);return{type:6,amount:Number(n),nativeTokens:i,nftId:o,unlockConditions:r,featureBlocks:s,immutableBlocks:a}}function Ke(e,t){e.writeUInt8("nftOutput.type",t.type),e.writeUInt64("nftOutput.amount",r.default(t.amount)),re(e,t.nativeTokens),e.writeFixedHex("nftOutput.nftId",20,t.nftId),Se(e,t.unlockConditions),O(e,t.featureBlocks),O(e,t.immutableBlocks)}function Ye(e){if(!e.hasRemaining(9))throw new Error(`Treasury Output data is ${e.length()} in length which is less than the minimimum size required of 9`);const t=e.readUInt8("treasuryOutput.type");if(2!==t)throw new Error(`Type mismatch in treasuryOutput ${t}`);const n=e.readUInt64("treasuryOutput.amount");return{type:2,amount:Number(n)}}function qe(e,t){e.writeUInt8("treasuryOutput.type",t.type),e.writeUInt64("treasuryOutput.amount",r.default(t.amount))}const We=Math.min(9,94,12,33,45);function Ze(e){const t=e.readUInt16("outputs.numOutputs"),n=[];for(let i=0;i<t;i++)n.push(Xe(e));return n}function Ve(e,t){if(t.length<1)throw new Error(`The minimum number of outputs is 1, you have provided ${t.length}`);if(t.length>128)throw new Error(`The maximum number of outputs is 128, you have provided ${t.length}`);e.writeUInt16("outputs.numOutputs",t.length);let n=0;for(let i=0;i<t.length;i++)if(Je(e,t[i]),3===t[i].type||4===t[i].type||5===t[i].type||6===t[i].type){n+=t[i].nativeTokens.length}if(n>64)throw new Error(`The maximum number of native tokens is 64, you have provided ${n}`)}function Xe(e){if(!e.hasRemaining(We))throw new Error(`Output data is ${e.length()} in length which is less than the minimimum size required of ${We}`);const t=e.readUInt8("output.type",!1);let n;if(2===t)n=Ye(e);else if(3===t)n=Oe(e);else if(5===t)n=Fe(e);else if(6===t)n=Ge(e);else{if(4!==t)throw new Error(`Unrecognized output type ${t}`);n=Me(e)}return n}function Je(e,t){if(2===t.type)qe(e,t);else if(3===t.type)Re(e,t);else if(5===t.type)De(e,t);else if(6===t.type)Ke(e,t);else{if(4!==t.type)throw new Error(`Unrecognized output type ${t.type}`);Pe(e,t)}}const je=11+ie+2+4;function Qe(e){if(!e.hasRemaining(je))throw new Error(`Transaction essence data is ${e.length()} in length which is less than the minimimum size required of ${je}`);const t=e.readUInt8("transactionEssence.type");if(0!==t)throw new Error(`Type mismatch in transactionEssence ${t}`);const n=e.readUInt64("message.networkId"),i=X(e),o=e.readFixedHex("transactionEssence.inputsCommitment",ie),r=Ze(e),s=It(e);if(s&&5!==s.type)throw new Error("Transaction essence can only contain embedded Tagged Data Payload");for(const e of i)if(0!==e.type)throw new Error("Transaction essence can only contain UTXO Inputs");return{type:0,networkId:n.toString(10),inputs:i,inputsCommitment:o,outputs:r,payload:s}}function et(e,t){var n;e.writeUInt8("transactionEssence.type",t.type),e.writeUInt64("message.networkId",r.default(null!==(n=t.networkId)&&void 0!==n?n:"0"));for(const e of t.inputs)if(0!==e.type)throw new Error("Transaction essence can only contain UTXO Inputs");J(e,t.inputs),e.writeFixedHex("transactionEssence.inputsCommitment",ie,t.inputsCommitment),Ve(e,t.outputs),wt(e,t.payload)}function tt(e){if(!e.hasRemaining(3))throw new Error(`Reference Unlock Block data is ${e.length()} in length which is less than the minimimum size required of 3`);const t=e.readUInt8("referenceUnlockBlock.type");if(1!==t)throw new Error(`Type mismatch in referenceUnlockBlock ${t}`);return{type:1,reference:e.readUInt16("referenceUnlockBlock.reference")}}function nt(e,t){e.writeUInt8("referenceUnlockBlock.type",t.type),e.writeUInt16("referenceUnlockBlock.reference",t.reference)}const it=1+t.Ed25519.SIGNATURE_SIZE+t.Ed25519.PUBLIC_KEY_SIZE;function ot(e){if(!e.hasRemaining(it))throw new Error(`Ed25519 signature data is ${e.length()} in length which is less than the minimimum size required of ${it}`);const n=e.readUInt8("ed25519Signature.type");if(0!==n)throw new Error(`Type mismatch in ed25519Signature ${n}`);return{type:0,publicKey:e.readFixedHex("ed25519Signature.publicKey",t.Ed25519.PUBLIC_KEY_SIZE),signature:e.readFixedHex("ed25519Signature.signature",t.Ed25519.SIGNATURE_SIZE)}}function rt(e,n){e.writeUInt8("ed25519Signature.type",n.type),e.writeFixedHex("ed25519Signature.publicKey",t.Ed25519.PUBLIC_KEY_SIZE,n.publicKey),e.writeFixedHex("ed25519Signature.signature",t.Ed25519.SIGNATURE_SIZE,n.signature)}const st=it;function at(e){if(!e.hasRemaining(st))throw new Error(`Signature data is ${e.length()} in length which is less than the minimimum size required of ${st}`);const t=e.readUInt8("signature.type",!1);let n;if(0!==t)throw new Error(`Unrecognized signature type ${t}`);return n=ot(e),n}function dt(e,t){if(0!==t.type)throw new Error(`Unrecognized signature type ${t.type}`);rt(e,t)}const ut=1+st;function lt(e){if(!e.hasRemaining(ut))throw new Error(`Signature Unlock Block data is ${e.length()} in length which is less than the minimimum size required of ${ut}`);const t=e.readUInt8("signatureUnlockBlock.type");if(0!==t)throw new Error(`Type mismatch in signatureUnlockBlock ${t}`);return{type:0,signature:at(e)}}function ct(e,t){e.writeUInt8("signatureUnlockBlock.type",t.type),dt(e,t.signature)}const ht=Math.min(ut,3);function pt(e){const t=e.readUInt16("transactionEssence.numUnlockBlocks"),n=[];for(let i=0;i<t;i++)n.push(mt(e));return n}function ft(e,t){e.writeUInt16("transactionEssence.numUnlockBlocks",t.length);for(let n=0;n<t.length;n++)gt(e,t[n])}function mt(e){if(!e.hasRemaining(ht))throw new Error(`Unlock Block data is ${e.length()} in length which is less than the minimimum size required of ${ht}`);const t=e.readUInt8("unlockBlock.type",!1);let n;if(0===t)n=lt(e);else{if(1!==t)throw new Error(`Unrecognized unlock block type ${t}`);n=tt(e)}return n}function gt(e,t){if(0===t.type)ct(e,t);else{if(1!==t.type)throw new Error(`Unrecognized unlock block type ${t.type}`);nt(e,t)}}const yt=4+G+9;const Tt=Math.min(8,ee,9,te,yt);function It(e){const n=e.readUInt32("payload.length");if(!e.hasRemaining(n))throw new Error(`Payload length ${n} exceeds the remaining data ${e.unused()}`);let i;if(n>0){const n=e.readUInt32("payload.type",!1);if(0===n)i=function(e){if(!e.hasRemaining(8))throw new Error(`Transaction Payload data is ${e.length()} in length which is less than the minimimum size required of 8`);const t=e.readUInt32("payloadTransaction.type");if(0!==t)throw new Error(`Type mismatch in payloadTransaction ${t}`);let n,i;if(0!==e.readUInt8("payloadTransaction.essenceType",!1))throw new Error(`Unrecognized transaction essence type ${t}`);return n=Qe(e),i=pt(e),{type:0,essence:n,unlockBlocks:i}}(e);else if(1===n)i=function(e){if(!e.hasRemaining(ee))throw new Error(`Milestone Payload data is ${e.length()} in length which is less than the minimimum size required of ${ee}`);const n=e.readUInt32("payloadMilestone.type");if(1!==n)throw new Error(`Type mismatch in payloadMilestone ${n}`);const i=e.readUInt32("payloadMilestone.index"),o=e.readUInt64("payloadMilestone.timestamp"),r=e.readUInt8("payloadMilestone.numParents"),s=[];for(let t=0;t<r;t++){const n=e.readFixedHex(`payloadMilestone.parentMessageId${t+1}`,d);s.push(n)}const a=e.readFixedHex("payloadMilestone.inclusionMerkleProof",l),u=e.readUInt32("payloadMilestone.nextPoWScore"),c=e.readUInt32("payloadMilestone.nextPoWScoreMilestoneIndex"),h=e.readUInt8("payloadMilestone.publicKeysCount"),p=[];for(let n=0;n<h;n++)p.push(e.readFixedHex("payloadMilestone.publicKey",t.Ed25519.PUBLIC_KEY_SIZE));const f=It(e);if(f&&3!==f.type)throw new Error("Milestones only support embedded receipt payload type");const m=e.readUInt8("payloadMilestone.signaturesCount"),g=[];for(let n=0;n<m;n++)g.push(e.readFixedHex("payloadMilestone.signature",t.Ed25519.SIGNATURE_SIZE));return{type:1,index:i,timestamp:Number(o),parentMessageIds:s,inclusionMerkleProof:a,nextPoWScore:u,nextPoWScoreMilestoneIndex:c,publicKeys:p,receipt:f,signatures:g}}(e);else if(3===n)i=function(e){if(!e.hasRemaining(te))throw new Error(`Receipt Payload data is ${e.length()} in length which is less than the minimimum size required of ${te}`);const t=e.readUInt32("payloadReceipt.type");if(3!==t)throw new Error(`Type mismatch in payloadReceipt ${t}`);const n=e.readUInt32("payloadReceipt.migratedAt"),i=e.readBoolean("payloadReceipt.final"),o=b(e),r=It(e);if(!r||4!==r.type)throw new Error(`payloadReceipts can only contain treasury payloads ${t}`);return{type:3,migratedAt:n,final:i,funds:o,transaction:r}}(e);else if(4===n)i=function(e){if(!e.hasRemaining(yt))throw new Error(`Treasury Transaction Payload data is ${e.length()} in length which is less than the minimimum size required of ${yt}`);const t=e.readUInt32("payloadTreasuryTransaction.type");if(4!==t)throw new Error(`Type mismatch in payloadTreasuryTransaction ${t}`);return{type:4,input:K(e),output:Ye(e)}}(e);else{if(5!==n)throw new Error(`Unrecognized payload type ${n}`);i=function(e){if(!e.hasRemaining(9))throw new Error(`Tagged Data Payload data is ${e.length()} in length which is less than the minimimum size required of 9`);const t=e.readUInt32("payloadTaggedData.type");if(5!==t)throw new Error(`Type mismatch in payloadTaggedData ${t}`);const n=e.readUInt8("payloadTaggedData.tagLength"),i=e.readFixedHex("payloadTaggedData.tag",n);let o;const r=e.readUInt32("payloadTaggedData.dataLength");return r>0&&(o=e.readFixedHex("payloadTaggedData.data",r)),{type:5,tag:i,data:o}}(e)}}return i}function wt(e,n){const i=e.getWriteIndex();if(e.writeUInt32("payload.length",0),n)if(0===n.type)!function(e,t){if(e.writeUInt32("payloadMilestone.type",t.type),0!==t.type)throw new Error(`Unrecognized transaction type ${t.type}`);et(e,t.essence),ft(e,t.unlockBlocks)}(e,n);else if(1===n.type)!function(e,n){if(e.writeUInt32("payloadMilestone.type",n.type),e.writeUInt32("payloadMilestone.index",n.index),e.writeUInt64("payloadMilestone.timestamp",r.default(n.timestamp)),n.parentMessageIds.length<kt)throw new Error(`A minimum of ${kt} parents is allowed, you provided ${n.parentMessageIds.length}`);if(n.parentMessageIds.length>_t)throw new Error(`A maximum of ${_t} parents is allowed, you provided ${n.parentMessageIds.length}`);if(new Set(n.parentMessageIds).size!==n.parentMessageIds.length)throw new Error("The milestone parents must be unique");const i=n.parentMessageIds.slice().sort();e.writeUInt8("payloadMilestone.numParents",n.parentMessageIds.length);for(let t=0;t<n.parentMessageIds.length;t++){if(i[t]!==n.parentMessageIds[t])throw new Error("The milestone parents must be lexographically sorted");e.writeFixedHex(`payloadMilestone.parentMessageId${t+1}`,d,n.parentMessageIds[t])}e.writeFixedHex("payloadMilestone.inclusionMerkleProof",l,n.inclusionMerkleProof),e.writeUInt32("payloadMilestone.nextPoWScore",n.nextPoWScore),e.writeUInt32("payloadMilestone.nextPoWScoreMilestoneIndex",n.nextPoWScoreMilestoneIndex),e.writeUInt8("payloadMilestone.publicKeysCount",n.publicKeys.length);for(let i=0;i<n.publicKeys.length;i++)e.writeFixedHex("payloadMilestone.publicKey",t.Ed25519.PUBLIC_KEY_SIZE,n.publicKeys[i]);wt(e,n.receipt),e.writeUInt8("payloadMilestone.signaturesCount",n.signatures.length);for(let i=0;i<n.signatures.length;i++)e.writeFixedHex("payloadMilestone.signature",t.Ed25519.SIGNATURE_SIZE,n.signatures[i])}(e,n);else if(3===n.type)!function(e,t){e.writeUInt32("payloadReceipt.type",t.type),e.writeUInt32("payloadReceipt.migratedAt",t.migratedAt),e.writeBoolean("payloadReceipt.final",t.final),L(e,t.funds),wt(e,t.transaction)}(e,n);else if(4===n.type)!function(e,t){e.writeUInt32("payloadTreasuryTransaction.type",t.type),Y(e,t.input),qe(e,t.output)}(e,n);else{if(5!==n.type)throw new Error(`Unrecognized transaction type ${n.type}`);!function(e,t){if(t.tag.length<1)throw new Error(`The tag length is ${t.tag.length/2}, which is less than the minimum size of 1`);if(t.tag&&t.tag.length/2>ne)throw new Error(`The tag length is ${t.tag.length/2}, which exceeds the maximum size of 64`);e.writeUInt32("payloadTaggedData.type",t.type),e.writeUInt8("payloadTaggedData.tagLength",t.tag.length/2),e.writeFixedHex("payloadTaggedData.tag",t.tag.length/2,t.tag),t.data?(e.writeUInt32("payloadTaggedData.dataLength",t.data.length/2),e.writeFixedHex("payloadTaggedData.data",t.data.length/2,t.data)):e.writeUInt32("payloadTaggedData.dataLength",0)}(e,n)}else;const o=e.getWriteIndex();e.setWriteIndex(i),e.writeUInt32("payload.length",o-i-4),e.setWriteIndex(o)}const Et=2+d+Tt+8,Ut=32768,_t=8,kt=1;function $t(e,t){var n,i,o,s;e.writeUInt8("message.protocolVersion",null!==(n=t.protocolVersion)&&void 0!==n?n:2);const a=null!==(o=null===(i=t.parentMessageIds)||void 0===i?void 0:i.length)&&void 0!==o?o:0;if(e.writeUInt8("message.numParents",a),t.parentMessageIds){if(a>_t)throw new Error(`A maximum of ${_t} parents is allowed, you provided ${a}`);if(new Set(t.parentMessageIds).size!==a)throw new Error("The message parents must be unique");const n=t.parentMessageIds.slice().sort();for(let i=0;i<a;i++){if(n[i]!==t.parentMessageIds[i])throw new Error("The message parents must be lexographically sorted");e.writeFixedHex(`message.parentMessageId${i+1}`,d,t.parentMessageIds[i])}}if(t.payload&&0!==t.payload.type&&1!==t.payload.type&&5!==t.payload.type)throw new Error("Messages can only contain transaction, milestone or tagged data payloads");wt(e,t.payload),e.writeUInt64("message.nonce",r.default(null!==(s=t.nonce)&&void 0!==s?s:"0"))}class Nt extends Error{constructor(e,t,n,i){super(e),this.route=t,this.httpStatus=n,this.code=i}}class At{constructor(e,t){var n,i,o,r,s;if(!e)throw new Error("The endpoint can not be empty");if(this._endpoint=e.replace(/\/+$/,""),this._basePath=null!==(n=null==t?void 0:t.basePath)&&void 0!==n?n:"/api/v2/",this._basePluginPath=null!==(i=null==t?void 0:t.basePluginPath)&&void 0!==i?i:"/api/plugins/",this._powProvider=null==t?void 0:t.powProvider,this._timeout=null==t?void 0:t.timeout,this._userName=null==t?void 0:t.userName,this._password=null==t?void 0:t.password,this._headers=null==t?void 0:t.headers,this._protocolVersion=null!==(o=null==t?void 0:t.protocolVersion)&&void 0!==o?o:2,this._userName&&this._password&&!this._endpoint.startsWith("https"))throw new Error("Basic authentication requires the endpoint to be https");if(this._userName&&this._password&&((null===(r=this._headers)||void 0===r?void 0:r.authorization)||(null===(s=this._headers)||void 0===s?void 0:s.Authorization)))throw new Error("You can not supply both user/pass and authorization header")}async health(){const e=await this.fetchStatus("/health");if(200===e)return!0;if(503===e)return!1;throw new Nt("Unexpected response code","/health",e)}async info(){return this.fetchJson(this._basePath,"get","info")}async tips(){return this.fetchJson(this._basePath,"get","tips")}async message(e){return this.fetchJson(this._basePath,"get",`messages/${e}`)}async messageMetadata(e){return this.fetchJson(this._basePath,"get",`messages/${e}/metadata`)}async messageRaw(e){return this.fetchBinary(this._basePath,"get",`messages/${e}/raw`)}async messageSubmit(e){var t,n;e.protocolVersion=this._protocolVersion;let o=0;if(this._powProvider&&(void 0===this._protocol&&await this.populateProtocolInfoCache(),o=null!==(n=null===(t=this._protocol)||void 0===t?void 0:t.minPoWScore)&&void 0!==n?n:0,!e.parentMessageIds||0===e.parentMessageIds.length)){const t=await this.tips();e.parentMessageIds=t.tipMessageIds}const r=new i.WriteStream;$t(r,e);const s=r.finalBytes();if(s.length>Ut)throw new Error(`The message length is ${s.length}, which exceeds the maximum size of 32768`);if(this._powProvider){const t=await this._powProvider.pow(s,o);e.nonce=t.toString()}return(await this.fetchJson(this._basePath,"post","messages",e)).messageId}async messageSubmitRaw(e){var n,o;if(e.length>Ut)throw new Error(`The message length is ${e.length}, which exceeds the maximum size of 32768`);if(e[0]=this._protocolVersion,this._powProvider&&t.ArrayHelper.equal(e.slice(-8),At.NONCE_ZERO)){void 0===this._protocol&&await this.populateProtocolInfoCache();const t=await this._powProvider.pow(e,null!==(o=null===(n=this._protocol)||void 0===n?void 0:n.minPoWScore)&&void 0!==o?o:0);i.BigIntHelper.write8(r.default(t),e,e.length-8)}return(await this.fetchBinary(this._basePath,"post","messages",e)).messageId}async messageChildren(e){return this.fetchJson(this._basePath,"get",`messages/${e}/children`)}async transactionIncludedMessage(e){return this.fetchJson(this._basePath,"get",`transactions/${e}/included-message`)}async output(e){return this.fetchJson(this._basePath,"get",`outputs/${e}`)}async milestone(e){return this.fetchJson(this._basePath,"get",`milestones/${e}`)}async milestoneUtxoChanges(e){return this.fetchJson(this._basePath,"get",`milestones/${e}/utxo-changes`)}async treasury(){return this.fetchJson(this._basePath,"get","treasury")}async receipts(e){return this.fetchJson(this._basePath,"get","receipts"+(void 0!==e?`/${e}`:""))}async peers(){return this.fetchJson(this._basePath,"get","peers")}async peerAdd(e,t){return this.fetchJson(this._basePath,"post","peers",{multiAddress:e,alias:t})}async peerDelete(e){return this.fetchJson(this._basePath,"delete",`peers/${e}`)}async peer(e){return this.fetchJson(this._basePath,"get",`peers/${e}`)}async bech32Hrp(){var e,t;return void 0===this._protocol&&await this.populateProtocolInfoCache(),null!==(t=null===(e=this._protocol)||void 0===e?void 0:e.bech32HRP)&&void 0!==t?t:""}async networkName(){var e,t;return void 0===this._protocol&&await this.populateProtocolInfoCache(),null!==(t=null===(e=this._protocol)||void 0===e?void 0:e.networkName)&&void 0!==t?t:""}async networkId(){var e,n;return void 0===this._protocol&&await this.populateProtocolInfoCache(),t.Blake2b.sum256(i.Converter.utf8ToBytes(null!==(n=null===(e=this._protocol)||void 0===e?void 0:e.networkName)&&void 0!==n?n:""))}async pluginFetch(e,t,n,i,o){return this.fetchJson(this._basePluginPath,t,`${e}${n}${this.combineQueryParams(i)}`,o)}async fetchStatus(e){return(await this.fetchWithTimeout("get",e)).status}async populateProtocolInfoCache(){if(void 0===this._protocol){const e=await this.info();this._protocol=e.protocol}}async fetchJson(e,t,n,i){const o=await this.fetchWithTimeout(t,`${e}${n}`,{"Content-Type":"application/json"},i?JSON.stringify(i):void 0);let r,s;if(o.ok){if(204===o.status)return{};try{const e=await o.json();if(!e.error)return e;r=e.error.message,s=e.error.code}catch{}}if(!r)try{const e=await o.json();e.error&&(r=e.error.message,s=e.error.code)}catch{}if(!r)try{const e=await o.text();if(e.length>0){const t=/code=(\d+), message=(.*)/.exec(e);3===(null==t?void 0:t.length)?(s=t[1],r=t[2]):r=e}}catch{}throw new Nt(null!=r?r:o.statusText,n,o.status,null!=s?s:o.status.toString())}async fetchBinary(e,t,n,i){var o,r,s;const a=await this.fetchWithTimeout(t,`${e}${n}`,{"Content-Type":"application/octet-stream"},i);let d;if(a.ok){if("get"===t)return new Uint8Array(await a.arrayBuffer());if(d=await a.json(),!(null==d?void 0:d.error))return null==d?void 0:d.data}throw d||(d=await a.json()),new Nt(null!==(r=null===(o=null==d?void 0:d.error)||void 0===o?void 0:o.message)&&void 0!==r?r:a.statusText,n,a.status,null===(s=null==d?void 0:d.error)||void 0===s?void 0:s.code)}async fetchWithTimeout(e,t,n,o){let r,s;void 0!==this._timeout&&(r=new AbortController,s=setTimeout((()=>{r&&r.abort()}),this._timeout));const a={};if(this._headers)for(const e in this._headers)a[e]=this._headers[e];if(n)for(const e in n)a[e]=n[e];if(this._userName&&this._password){const e=i.Converter.bytesToBase64(i.Converter.utf8ToBytes(`${this._userName}:${this._password}`));a.Authorization=`Basic ${e}`}try{return await fetch(`${this._endpoint}${t}`,{method:e,headers:a,body:o,signal:r?r.signal:void 0})}catch(e){throw e instanceof Error&&"AbortError"===e.name?new Error("Timeout"):e}finally{s&&clearTimeout(s)}}combineQueryParams(e){return e&&e.length>0?`?${e.join("&")}`:""}}At.NONCE_ZERO=new Uint8Array([0,0,0,0,0,0,0,0]);class xt{constructor(e,t){var n;this._client="string"==typeof e?new At(e):e,this._basePluginPath=null!==(n=null==t?void 0:t.basePluginPath)&&void 0!==n?n:"indexer/v1/"}async outputs(e){const t=[];return e&&(void 0!==e.addressBech32&&t.push(`address=${e.addressBech32}`),e.hasDustReturnCondition&&t.push(`hasDustReturnCondition=${e.hasDustReturnCondition}`),void 0!==e.dustReturnAddressBech32&&t.push(`dustReturnAddress=${e.dustReturnAddressBech32}`),e.hasExpirationCondition&&t.push(`hasExpirationCondition=${e.hasExpirationCondition}`),void 0!==e.expirationReturnAddressBech32&&t.push(`expirationReturnAddress=${e.expirationReturnAddressBech32}`),void 0!==e.expiresBefore&&t.push(`expiresBefore=${e.expiresBefore}`),void 0!==e.expiresAfter&&t.push(`expiresAfter=${e.expiresAfter}`),void 0!==e.expiresBeforeMilestone&&t.push(`expiresBeforeMilestone=${e.expiresBeforeMilestone}`),void 0!==e.expiresAfterMilestone&&t.push(`expiresAfterMilestone=${e.expiresAfterMilestone}`),void 0!==e.hasTimelockCondition&&t.push(`hasTimelockCondition=${e.hasTimelockCondition}`),void 0!==e.timelockedBefore&&t.push(`timelockedBefore=${e.timelockedBefore}`),void 0!==e.timelockedAfter&&t.push(`timelockedAfter=${e.timelockedAfter}`),void 0!==e.timelockedBefore&&t.push(`timelockedBefore=${e.timelockedBefore}`),void 0!==e.timelockedAfter&&t.push(`timelockedAfter=${e.timelockedAfter}`),void 0!==e.timelockedBeforeMilestone&&t.push(`timelockedBeforeMilestone=${e.timelockedBeforeMilestone}`),void 0!==e.timelockedAfterMilestone&&t.push(`timelockedAfterMilestone=${e.timelockedAfterMilestone}`),void 0!==e.hasNativeTokens&&t.push(`hasNativeTokens=${e.hasNativeTokens}`),void 0!==e.minNativeTokenCount&&t.push(`minNativeTokenCount=${e.minNativeTokenCount}`),void 0!==e.maxNativeTokenCount&&t.push(`maxNativeTokenCount=${e.maxNativeTokenCount}`),void 0!==e.senderBech32&&t.push(`sender=${e.senderBech32}`),void 0!==e.tagHex&&t.push(`tag=${e.tagHex}`),void 0!==e.createdBefore&&t.push(`createdBefore=${e.createdBefore}`),void 0!==e.createdAfter&&t.push(`createdAfter=${e.createdAfter}`),void 0!==e.pageSize&&t.push(`pageSize=${e.pageSize}`),void 0!==e.cursor&&t.push(`cursor=${e.cursor}`)),this._client.pluginFetch(this._basePluginPath,"get","outputs",t)}async aliases(e){const t=[];return e&&(void 0!==e.stateControllerBech32&&t.push(`stateController=${e.stateControllerBech32}`),void 0!==e.governorBech32&&t.push(`governor=${e.governorBech32}`),void 0!==e.hasNativeTokens&&t.push(`hasNativeTokens=${e.hasNativeTokens}`),void 0!==e.minNativeTokenCount&&t.push(`minNativeTokenCount=${e.minNativeTokenCount}`),void 0!==e.maxNativeTokenCount&&t.push(`maxNativeTokenCount=${e.maxNativeTokenCount}`),void 0!==e.issuerBech32&&t.push(`issuer=${e.issuerBech32}`),void 0!==e.senderBech32&&t.push(`sender=${e.senderBech32}`),void 0!==e.createdBefore&&t.push(`createdBefore=${e.createdBefore}`),void 0!==e.createdAfter&&t.push(`createdAfter=${e.createdAfter}`),void 0!==e.pageSize&&t.push(`pageSize=${e.pageSize}`),void 0!==e.cursor&&t.push(`cursor=${e.cursor}`)),this._client.pluginFetch(this._basePluginPath,"get","aliases",t)}async alias(e){if(!i.Converter.isHex(e))throw new Error("The alias id does not appear to be hex format");return this._client.pluginFetch(this._basePluginPath,"get",`aliases/${e}`)}async nfts(e){const t=[];return e&&(void 0!==e.addressBech32&&t.push(`address=${e.addressBech32}`),e.hasDustReturnCondition&&t.push(`hasDustReturnCondition=${e.hasDustReturnCondition}`),void 0!==e.dustReturnAddressBech32&&t.push(`dustReturnAddress=${e.dustReturnAddressBech32}`),e.hasExpirationCondition&&t.push(`hasExpirationCondition=${e.hasExpirationCondition}`),void 0!==e.expirationReturnAddressBech32&&t.push(`expirationReturnAddress=${e.expirationReturnAddressBech32}`),void 0!==e.expiresBefore&&t.push(`expiresBefore=${e.expiresBefore}`),void 0!==e.expiresAfter&&t.push(`expiresAfter=${e.expiresAfter}`),void 0!==e.expiresBeforeMilestone&&t.push(`expiresBeforeMilestone=${e.expiresBeforeMilestone}`),void 0!==e.expiresAfterMilestone&&t.push(`expiresAfterMilestone=${e.expiresAfterMilestone}`),void 0!==e.hasTimelockCondition&&t.push(`hasTimelockCondition=${e.hasTimelockCondition}`),void 0!==e.timelockedBefore&&t.push(`timelockedBefore=${e.timelockedBefore}`),void 0!==e.timelockedAfter&&t.push(`timelockedAfter=${e.timelockedAfter}`),void 0!==e.timelockedBeforeMilestone&&t.push(`timelockedBeforeMilestone=${e.timelockedBeforeMilestone}`),void 0!==e.timelockedAfterMilestone&&t.push(`timelockedAfterMilestone=${e.timelockedAfterMilestone}`),void 0!==e.hasNativeTokens&&t.push(`hasNativeTokens=${e.hasNativeTokens}`),void 0!==e.minNativeTokenCount&&t.push(`minNativeTokenCount=${e.minNativeTokenCount}`),void 0!==e.maxNativeTokenCount&&t.push(`maxNativeTokenCount=${e.maxNativeTokenCount}`),void 0!==e.issuerBech32&&t.push(`issuer=${e.issuerBech32}`),void 0!==e.senderBech32&&t.push(`sender=${e.senderBech32}`),void 0!==e.tagHex&&t.push(`tag=${e.tagHex}`),void 0!==e.createdBefore&&t.push(`createdBefore=${e.createdBefore}`),void 0!==e.createdAfter&&t.push(`createdAfter=${e.createdAfter}`),void 0!==e.pageSize&&t.push(`pageSize=${e.pageSize}`),void 0!==e.cursor&&t.push(`cursor=${e.cursor}`)),this._client.pluginFetch(this._basePluginPath,"get","nfts",t)}async nft(e){if(!i.Converter.isHex(e))throw new Error("The nft id does not appear to be hex format");return this._client.pluginFetch(this._basePluginPath,"get",`nfts/${e}`)}async foundries(e){const t=[];return e&&(void 0!==e.aliasAddressBech32&&t.push(`aliasAddress=${e.aliasAddressBech32}`),void 0!==e.hasNativeTokens&&t.push(`hasNativeTokens=${e.hasNativeTokens}`),void 0!==e.minNativeTokenCount&&t.push(`minNativeTokenCount=${e.minNativeTokenCount}`),void 0!==e.maxNativeTokenCount&&t.push(`maxNativeTokenCount=${e.maxNativeTokenCount}`),void 0!==e.createdBefore&&t.push(`createdBefore=${e.createdBefore}`),void 0!==e.createdAfter&&t.push(`createdAfter=${e.createdAfter}`),void 0!==e.pageSize&&t.push(`pageSize=${e.pageSize}`),void 0!==e.cursor&&t.push(`cursor=${e.cursor}`)),this._client.pluginFetch(this._basePluginPath,"get","foundries",t)}async foundry(e){if(!i.Converter.isHex(e))throw new Error("The foundry id does not appear to be hex format");return this._client.pluginFetch(this._basePluginPath,"get",`foundries/${e}`)}}class vt{static encodedLen(e){return e.length*vt.TRITS_PER_TRYTE}static encode(e,t,n){let i=0;for(let o=0;o<n.length;o++){const r=364+(n[o]<<24>>24),s=Math.trunc(r%27),a=Math.trunc(r/27);e[t+i]=vt.TRYTE_VALUE_TO_TRITS[s][0],e[t+i+1]=vt.TRYTE_VALUE_TO_TRITS[s][1],e[t+i+2]=vt.TRYTE_VALUE_TO_TRITS[s][2],e[t+i+3]=vt.TRYTE_VALUE_TO_TRITS[a][0],e[t+i+4]=vt.TRYTE_VALUE_TO_TRITS[a][1],e[t+i+5]=vt.TRYTE_VALUE_TO_TRITS[a][2],i+=6}return i}}vt.TRYTE_VALUE_TO_TRITS=[[-1,-1,-1],[0,-1,-1],[1,-1,-1],[-1,0,-1],[0,0,-1],[1,0,-1],[-1,1,-1],[0,1,-1],[1,1,-1],[-1,-1,0],[0,-1,0],[1,-1,0],[-1,0,0],[0,0,0],[1,0,0],[-1,1,0],[0,1,0],[1,1,0],[-1,-1,1],[0,-1,1],[1,-1,1],[-1,0,1],[0,0,1],[1,0,1],[-1,1,1],[0,1,1],[1,1,1]],vt.TRITS_PER_TRYTE=3;const St="m/44'/4218'";function Ct(e){const n=new t.Bip32Path(St);return n.pushHardened(e.accountIndex),n.pushHardened(e.isInternal?1:0),n.pushHardened(e.addressIndex),e.isInternal?(e.isInternal=!1,e.addressIndex++):e.isInternal=!0,n.toString()}class Bt{static toBech32(e,n,i){const o=new Uint8Array(1+n.length);return o[0]=e,o.set(n,1),t.Bech32.encode(i,o)}static fromBech32(e,n){const i=t.Bech32.decode(e);if(i){if(i.humanReadablePart!==n)throw new Error(`The hrp part of the address should be ${n}, it is ${i.humanReadablePart}`);if(0===i.data.length)throw new Error("The data part of the address should be at least length 1, it is 0");return{addressType:i.data[0],addressBytes:i.data.slice(1)}}}static matches(e,n){return t.Bech32.matches(n,e)}}async function Mt(e,t,n,i){var o;return Pt(e,t,{accountIndex:n,addressIndex:null!==(o=null==i?void 0:i.startIndex)&&void 0!==o?o:0,isInternal:!1},Ct,i)}async function Pt(e,n,i,o,r){var a,d;const u="string"==typeof e?new At(e):e,l=await u.bech32Hrp(),c=null!==(a=null==r?void 0:r.requiredCount)&&void 0!==a?a:Number.MAX_SAFE_INTEGER,h=null!==(d=null==r?void 0:r.zeroCount)&&void 0!==d?d:20;let p=!1;const f=[];let m=0;do{const e=o(i),r=n.generateSeedFromPath(new t.Bip32Path(e)),a=new s(r.keyPair().publicKey).toAddress(),d=Bt.toBech32(0,a,l),g=await Ot(u,d);0===g?(m++,m>=h&&(p=!0)):(f.push({address:d,path:e,balance:g}),f.length===c&&(p=!0))}while(!p);return f}async function Ot(e,t){const n=new xt(e);let i,o=0,r=0;do{const s=await n.outputs({addressBech32:t,pageSize:20,cursor:i});o=s.items.length,i=s.cursor;for(const t of s.items){const n=await e.output(t);3!==n.output.type||n.isSpent||(r+=n.output.amount)}}while(o>0&&i);return r}async function Rt(e,t){const n="string"==typeof e?new At(e):e,i=await n.message(t);if(!i)throw new Error("The message does not exist.");const o=await n.tips();o.tipMessageIds.includes(t)||o.tipMessageIds.unshift(t),o.tipMessageIds.length>_t&&(o.tipMessageIds=o.tipMessageIds.slice(0,_t)),o.tipMessageIds.sort();const r={parentMessageIds:o.tipMessageIds};return{message:i,messageId:await n.messageSubmit(r)}}async function zt(e,t){const n="string"==typeof e?new At(e):e,i=await n.message(t);if(!i)throw new Error("The message does not exist.");const o={payload:i.payload};return{message:i,messageId:await n.messageSubmit(o)}}async function Ht(e,t,n,i){const o="string"==typeof e?new At(e):e,r={payload:bt(t,n,i)};return{messageId:await o.messageSubmit(r),message:r}}function bt(e,n,o){if(!e||0===e.length)throw new Error("You must specify some inputs");if(!n||0===n.length)throw new Error("You must specify some outputs");let r;if(o){if(r="string"==typeof(null==o?void 0:o.tag)?i.Converter.utf8ToHex(o.tag):i.Converter.bytesToHex(o.tag),r.length/2<1)throw new Error(`The tag length is ${r.length/2}, which is less than the minimum size of 1`);if(r.length/2>ne)throw new Error(`The tag length is ${r.length/2}, which exceeds the maximum size of 64`)}const s=[];for(const e of n){if(0!==e.addressType)throw new Error(`Unrecognized output address type ${e.addressType}`);{const t={type:3,amount:e.amount,nativeTokens:[],unlockConditions:[{type:0,address:{type:e.addressType,address:e.address}}],featureBlocks:[]},n=new i.WriteStream;Je(n,t);const o=n.finalBytes();s.push({output:t,serializedBytes:o,serializedHex:i.Converter.bytesToHex(o)})}}const a=e.map((e=>{const t=new i.WriteStream;Q(t,e.input);const n=t.finalBytes();return{...e,serializedBytes:n,serializedHex:i.Converter.bytesToHex(n)}})).sort(((e,t)=>e.serializedHex.localeCompare(t.serializedHex))),d=s.sort(((e,t)=>e.serializedHex.localeCompare(t.serializedHex))),u=new t.Blake2b(t.Blake2b.SIZE_256);for(const e of a)u.update(e.serializedBytes);const l=i.Converter.bytesToHex(u.final()),c={type:0,inputs:a.map((e=>e.input)),inputsCommitment:l,outputs:d.map((e=>e.output)),payload:r?{type:5,tag:r,data:(null==o?void 0:o.data)?"string"==typeof o.data?i.Converter.utf8ToHex(o.data):i.Converter.bytesToHex(o.data):void 0}:void 0},h=new i.WriteStream;et(h,c);const p=h.finalBytes(),f=t.Blake2b.sum256(p),m=[],g={};for(const e of a){const n=i.Converter.bytesToHex(e.addressKeyPair.publicKey);g[n]?m.push({type:1,reference:g[n].unlockIndex}):(m.push({type:0,signature:{type:0,publicKey:n,signature:i.Converter.bytesToHex(t.Ed25519.sign(e.addressKeyPair.privateKey,f))}}),g[n]={keyPair:e.addressKeyPair,unlockIndex:m.length-1})}return{type:0,essence:c,unlockBlocks:m}}async function Lt(e,t,n,o,r,s){var a;const d="string"==typeof e?new At(e):e,u=await d.bech32Hrp(),l=o.map((e=>{const t=Bt.fromBech32(e.addressBech32,u);if(!t)throw new Error("Unable to decode bech32 address");return{address:i.Converter.bytesToHex(t.addressBytes),addressType:t.addressType,amount:e.amount}}));return Dt(e,t,{accountIndex:n,addressIndex:null!==(a=null==s?void 0:s.startIndex)&&void 0!==a?a:0,isInternal:!1},Ct,l,r,null==s?void 0:s.zeroCount)}async function Ft(e,t,n,i,o,r){var s;const a=i.map((e=>({address:e.addressEd25519,addressType:0,amount:e.amount})));return Dt(e,t,{accountIndex:n,addressIndex:null!==(s=null==r?void 0:r.startIndex)&&void 0!==s?s:0,isInternal:!1},Ct,a,o,null==r?void 0:r.zeroCount)}async function Dt(e,t,n,i,o,r,s){const a=await Gt(e,t,n,i,o,s),d=await Ht(e,a,o,r);return{messageId:d.messageId,message:d.message}}async function Gt(e,n,i,o,r,a=5){const d="string"==typeof e?new At(e):e,u=await d.bech32Hrp();let l=0;for(const e of r)l+=e.amount;let c=0;const h=[];let p=!1,f=0;do{const m=o(i),g=n.generateSeedFromPath(new t.Bip32Path(m)).keyPair(),y=new s(g.publicKey).toAddress(),T=new xt(e),I=await T.outputs({addressBech32:Bt.toBech32(0,y,u)});if(0===I.items.length)f++,f>=a&&(p=!0);else for(const e of I.items){const t=await d.output(e);if(!t.isSpent&&c<l)if(0===t.output.amount)f++,f>=a&&(p=!0);else{c+=t.output.amount;const e={type:0,transactionId:t.transactionId,transactionOutputIndex:t.outputIndex};if(h.push({input:e,addressKeyPair:g}),c>=l){if(c-l>0&&3===t.output.type){const e=t.output.unlockConditions.find((e=>0===e.type));e&&0===e.type&&r.push({amount:c-l,address:e.address.address,addressType:e.address.type})}p=!0}}}}while(!p);if(c<l)throw new Error("There are not enough funds in the inputs for the required balance");return h}var Kt;Bt.BECH32_DEFAULT_HRP_MAIN="iota",Bt.BECH32_DEFAULT_HRP_DEV="atoi",e.ConflictReason=void 0,(Kt=e.ConflictReason||(e.ConflictReason={}))[Kt.none=0]="none",Kt[Kt.inputUTXOAlreadySpent=1]="inputUTXOAlreadySpent",Kt[Kt.inputUTXOAlreadySpentInThisMilestone=2]="inputUTXOAlreadySpentInThisMilestone",Kt[Kt.inputUTXONotFound=3]="inputUTXONotFound",Kt[Kt.inputOutputSumMismatch=4]="inputOutputSumMismatch",Kt[Kt.invalidSignature=5]="invalidSignature",Kt[Kt.invalidNetworkId=6]="invalidNetworkId",Kt[Kt.semanticValidationFailed=255]="semanticValidationFailed";class Yt{static score(e){const n=e.slice(0,-8),o=t.Blake2b.sum256(n),r=i.BigIntHelper.read8(e,e.length-8),s=Yt.trailingZeros(o,r);return Math.pow(3,s)/e.length}static calculateTargetZeros(e,t){return Math.ceil(Math.log(e.length*t)/this.LN3)}static trailingZeros(e,n){const o=new Int8Array(t.Curl.HASH_LENGTH),r=vt.encode(o,0,e),s=new Uint8Array(8);i.BigIntHelper.write8(n,s,0),vt.encode(o,r,s);const a=new t.Curl;a.absorb(o,0,t.Curl.HASH_LENGTH);const d=new Int8Array(t.Curl.HASH_LENGTH);return a.squeeze(d,0,t.Curl.HASH_LENGTH),Yt.trinaryTrailingZeros(d)}static trinaryTrailingZeros(e,t=e.length){let n=0;for(let i=t-1;i>=0&&0===e[i];i--)n++;return n}static performPow(e,n,o){let s,a=r.default(o);const d=new Int8Array(t.Curl.HASH_LENGTH),u=vt.encode(d,0,e),l=new Uint8Array(8);do{i.BigIntHelper.write8(a,l,0),vt.encode(d,u,l);const e=new Int8Array(t.Curl.STATE_LENGTH);e.set(d,0),t.Curl.transform(e,81),Yt.trinaryTrailingZeros(e,t.Curl.HASH_LENGTH)>=n?s=a:a=a.plus(1)}while(void 0===s);return s?s.toString():"0"}}Yt.LN3=1.0986122886681098;const qt={[e.ConflictReason.none]:"Not conflicting",[e.ConflictReason.inputUTXOAlreadySpent]:"The referenced UTXO was already spent",[e.ConflictReason.inputUTXOAlreadySpentInThisMilestone]:"The referenced UTXO was already spent while confirming this milestone",[e.ConflictReason.inputUTXONotFound]:"The referenced UTXO cannot be found",[e.ConflictReason.inputOutputSumMismatch]:"The sum of the inputs and output values does not match",[e.ConflictReason.invalidSignature]:"The unlock block signature is invalid",[e.ConflictReason.invalidNetworkId]:"The networkId in the essence does not match the nodes configuration",[e.ConflictReason.semanticValidationFailed]:"The semantic validation failed"};class Wt{constructor(e){this._secretKey=null!=e?e:new Uint8Array}static fromMnemonic(e){return new Wt(t.Bip39.mnemonicToSeed(e))}keyPair(){const e=t.Ed25519.keyPairFromSeed(this._secretKey);return{publicKey:e.publicKey,privateKey:e.privateKey}}generateSeedFromPath(e){const n=t.Slip0010.derivePath(this._secretKey,e);return new Wt(n.privateKey)}toBytes(){return this._secretKey}}let Zt=(e,t)=>void 0!==t?console.log(e,t):console.log(e);function Vt(e,t){t&&(0===t.type?Xt(e,t):1===t.type?jt(e,t):3===t.type?Qt(e,t):4===t.type?en(e,t):5===t.type&&Jt(e,t))}function Xt(e,t){if(t){if(Zt(`${e}Transaction Payload`),0===t.essence.type){if(Zt(`${e}\tNetwork Id:`,t.essence.networkId),t.essence.inputs){Zt(`${e}\tInputs:`,t.essence.inputs.length);for(const n of t.essence.inputs)on(`${e}\t\t`,n)}if(Zt(`${e}\tInputs Commitment:`,t.essence.inputsCommitment),t.essence.outputs){Zt(`${e}\tOutputs:`,t.essence.outputs.length);for(const n of t.essence.outputs)rn(`${e}\t\t`,n)}}if(t.unlockBlocks){Zt(`${e}\tUnlock Blocks:`,t.unlockBlocks.length);for(const n of t.unlockBlocks)sn(`${e}\t\t`,n)}}}function Jt(e,t){t&&(Zt(`${e}Tagged Data Payload`),Zt(`${e}\tTag:`,t.tag?i.Converter.hexToUtf8(t.tag):"None"),Zt(`${e}\tData:`,t.data?i.Converter.hexToUtf8(t.data):"None"))}function jt(e,t){if(t){Zt(`${e}Milestone Payload`),Zt(`${e}\tIndex:`,t.index),Zt(`${e}\tTimestamp:`,t.timestamp);for(let n=0;n<t.parentMessageIds.length;n++)Zt(`${e}\tParent ${n+1}:`,t.parentMessageIds[n]);Zt(`${e}\tInclusion Merkle Proof:`,t.inclusionMerkleProof),t.nextPoWScore&&Zt(`${e}\tNext PoW Score:`,t.nextPoWScore),t.nextPoWScoreMilestoneIndex&&Zt(`${e}\tNext PoW Score Milestone Index:`,t.nextPoWScoreMilestoneIndex),Zt(`${e}\tPublic Keys:`,t.publicKeys),Zt(`${e}\tSignatures:`,t.signatures),Qt(`${e}\t`,t.receipt)}}function Qt(e,t){if(t){Zt(`${e}Receipt Payload`),Zt(`${e}\tMigrated At:`,t.migratedAt),Zt(`${e}\tFinal:`,t.final),Zt(`${e}\tFunds:`,t.funds.length);for(const n of t.funds)an(`${e}\t\t`,n);en(`${e}\t\t`,t.transaction)}}function en(e,t){t&&(Zt(`${e}Treasury Transaction Payload`),on(e,t.input),rn(e,t.output))}function tn(e,t){0===(null==t?void 0:t.type)?(Zt(`${e}Ed25519 Address`),Zt(`${e}\tAddress:`,t.address)):1===(null==t?void 0:t.type)?(Zt(`${e}BLS Address`),Zt(`${e}\tAddress:`,t.address)):8===(null==t?void 0:t.type)?(Zt(`${e}Alias Address`),Zt(`${e}\tAddress:`,t.address)):(null==t?void 0:t.type)===a&&(Zt(`${e}NFT Address`),Zt(`${e}\tAddress:`,t.address))}function nn(e,t){0===(null==t?void 0:t.type)&&(Zt(`${e}Ed25519 Signature`),Zt(`${e}\tPublic Key:`,t.publicKey),Zt(`${e}\tSignature:`,t.signature))}function on(e,t){t&&(0===t.type?(Zt(`${e}UTXO Input`),Zt(`${e}\tTransaction Id:`,t.transactionId),Zt(`${e}\tTransaction Output Index:`,t.transactionOutputIndex)):1===t.type&&(Zt(`${e}Treasury Input`),Zt(`${e}\tMilestone Hash:`,t.milestoneId)))}function rn(e,t){t&&(2===t.type?(Zt(`${e}Treasury Output`),Zt(`${e}\t\tAmount:`,t.amount)):3===t.type?(Zt(`${e}Basic Output`),Zt(`${e}\t\tAmount:`,t.amount),dn(`${e}\t\t`,t.nativeTokens),pn(`${e}\t\t`,t.unlockConditions),ln(`${e}\t\t`,t.featureBlocks)):4===t.type?(Zt(`${e}Alias Output`),Zt(`${e}\t\tAmount:`,t.amount),dn(`${e}\t\t`,t.nativeTokens),Zt(`${e}\t\tAlias Id:`,t.aliasId),Zt(`${e}\t\tState Index:`,t.stateIndex),Zt(`${e}\t\tState Metadata:`,t.stateMetadata),Zt(`${e}\t\tFoundry Counter:`,t.foundryCounter),pn(`${e}\t\t`,t.unlockConditions),ln(`${e}\t\t`,t.featureBlocks),cn(`${e}\t\t`,t.immutableBlocks)):5===t.type?(Zt(`${e}Foundry Output`),Zt(`${e}\t\tAmount:`,t.amount),dn(`${e}\t\t`,t.nativeTokens),Zt(`${e}\t\tSerial Number:`,t.serialNumber),Zt(`${e}\t\tToken Tag:`,t.tokenTag),Zt(`${e}\t\tCirculating Supply:`,t.circulatingSupply),Zt(`${e}\t\tMaximum Supply:`,t.maximumSupply),un(`${e}\t\t`,t.tokenScheme),pn(`${e}\t\t`,t.unlockConditions),ln(`${e}\t\t`,t.featureBlocks),cn(`${e}\t\t`,t.immutableBlocks)):6===t.type&&(Zt(`${e}NFT Output`),Zt(`${e}\t\tAmount:`,t.amount),dn(`${e}\t\t`,t.nativeTokens),Zt(`${e}\t\tNFT Id:`,t.nftId),pn(`${e}\t\t`,t.unlockConditions),ln(`${e}\t\t`,t.featureBlocks),cn(`${e}\t\t`,t.immutableBlocks)))}function sn(e,t){t&&(0===t.type?(Zt(`${e}\tSignature Unlock Block`),nn(`${e}\t\t`,t.signature)):1===t.type?(Zt(`${e}\tReference Unlock Block`),Zt(`${e}\t\tReference:`,t.reference)):2===t.type?(Zt(`${e}\tAlias Unlock Block`),Zt(`${e}\t\tReference:`,t.reference)):3===t.type&&(Zt(`${e}\tNFT Unlock Block`),Zt(`${e}\t\tReference:`,t.reference)))}function an(e,t){t&&(Zt(`${e}\tFund`),Zt(`${e}\t\tTail Transaction Hash:`,t.tailTransactionHash),tn(`${e}\t\t`,t.address),Zt(`${e}\t\tDeposit:`,t.deposit))}function dn(e,t){Zt(`${e}Native Tokens`);for(const n of t)Zt(`${e}\t\tId:`,n.id),Zt(`${e}\t\tAmount:`,n.amount)}function un(e,t){0===t.type&&Zt(`${e}\tSimple Token Scheme`)}function ln(e,t){Zt(`${e}Feature Blocks`);for(const n of t)hn(`${e}\t\t`,n)}function cn(e,t){Zt(`${e}Immutable Feature Blocks`);for(const n of t)hn(`${e}\t\t`,n)}function hn(e,t){0===t.type?(Zt(`${e}\tSender Feature Block`),tn(`${e}\t\t`,t.address)):1===t.type?(Zt(`${e}\tIssuer Feature Block`),tn(`${e}\t\t`,t.address)):2===t.type?(Zt(`${e}\tMetadata Feature Block`),Zt(`${e}\t\tData:`,t.data)):3===t.type&&(Zt(`${e}\tTag Feature Block`),Zt(`${e}\t\tTag:`,t.tag))}function pn(e,t){Zt(`${e}Unlock Conditions`);for(const n of t)fn(`${e}\t\t`,n)}function fn(e,t){0===t.type?(Zt(`${e}\tAddress Unlock Condition`),tn(`${e}\t\t`,t.address)):1===t.type?(Zt(`${e}\tDust Deposit Return Unlock Condition`),tn(`${e}\t\t`,t.returnAddress),Zt(`${e}\t\tAmount:`,t.amount)):2===t.type?(Zt(`${e}\tTimelock Unlock Condition`),Zt(`${e}\t\tMilestone Index:`,t.milestoneIndex),Zt(`${e}\t\tUnixTime:`,t.unixTime)):3===t.type?(Zt(`${e}\tExpiration Unlock Condition`),tn(`${e}\t\t`,t.returnAddress),Zt(`${e}\t\tMilestone Index:`,t.milestoneIndex),Zt(`${e}\t\tUnixTime:`,t.unixTime)):4===t.type?(Zt(`${e}\tState Controller Address Unlock Condition`),tn(`${e}\t\t`,t.address)):5===t.type?(Zt(`${e}\tGovernor Address Unlock Condition`),tn(`${e}\t\t`,t.address)):6===t.type&&(Zt(`${e}\tImmutable Alias Unlock Condition`),tn(`${e}\t\t`,t.address))}class mn{static formatBest(e,t=2){return mn.formatUnits(e,mn.calculateBest(e),t)}static formatUnits(e,t,n=2){if(!mn.UNIT_MAP[t])throw new Error(`Unrecognized unit ${t}`);return e?"i"===t?`${e} i`:`${mn.convertUnits(e,"i",t).toFixed(n)} ${t}`:`0 ${t}`}static calculateBest(e){let t="i";if(!e)return t;const n=Math.abs(e).toString().length;return n>mn.UNIT_MAP.Pi.dp?t="Pi":n>mn.UNIT_MAP.Ti.dp?t="Ti":n>mn.UNIT_MAP.Gi.dp?t="Gi":n>mn.UNIT_MAP.Mi.dp?t="Mi":n>mn.UNIT_MAP.Ki.dp&&(t="Ki"),t}static convertUnits(e,t,n){if(!e)return 0;if(!mn.UNIT_MAP[t])throw new Error(`Unrecognized fromUnit ${t}`);if(!mn.UNIT_MAP[n])throw new Error(`Unrecognized toUnit ${n}`);if("i"===t&&e%1!=0)throw new Error("If fromUnit is 'i' the value must be an integer value");if(t===n)return Number(e);const i=e<0?-1:1,o=Math.abs(Number(e))*mn.UNIT_MAP[t].val/mn.UNIT_MAP[n].val,r=mn.UNIT_MAP[n].dp;let s=o.toString();s.includes("e")&&(s=o.toFixed(Number.parseInt(s.split("-")[1],10)));const a=s.split(".");return 1===a.length&&a.push("0"),a[1]=a[1].slice(0,r),Number.parseFloat(`${a[0]}.${a[1]}`)*i}}mn.UNIT_MAP={i:{val:1,dp:0},Ki:{val:1e3,dp:3},Mi:{val:1e6,dp:6},Gi:{val:1e9,dp:9},Ti:{val:1e12,dp:12},Pi:{val:1e15,dp:15}},e.ADDRESS_UNLOCK_CONDITION_TYPE=0,e.ALIAS_ADDRESS_LENGTH=20,e.ALIAS_ADDRESS_TYPE=8,e.ALIAS_ID_LENGTH=20,e.ALIAS_OUTPUT_TYPE=4,e.ALIAS_UNLOCK_BLOCK_TYPE=2,e.ARRAY_LENGTH=2,e.B1T6=vt,e.BASIC_OUTPUT_TYPE=3,e.BLS_ADDRESS_LENGTH=32,e.BLS_ADDRESS_TYPE=1,e.Bech32Helper=Bt,e.CONFLICT_REASON_STRINGS=qt,e.ClientError=Nt,e.DEFAULT_PROTOCOL_VERSION=2,e.DUST_DEPOSIT_RETURN_UNLOCK_CONDITION_TYPE=1,e.ED25519_ADDRESS_TYPE=0,e.ED25519_SEED_TYPE=1,e.ED25519_SIGNATURE_TYPE=0,e.EXPIRATION_UNLOCK_CONDITION_TYPE=3,e.Ed25519Address=s,e.Ed25519Seed=Wt,e.FOUNDRY_OUTPUT_TYPE=5,e.GOVERNOR_ADDRESS_UNLOCK_CONDITION_TYPE=5,e.IMMUTABLE_ALIAS_UNLOCK_CONDITION_TYPE=6,e.INPUTS_COMMITMENT_SIZE=ie,e.IOTA_BIP44_BASE_PATH=St,e.ISSUER_FEATURE_BLOCK_TYPE=1,e.IndexerPluginClient=xt,e.LocalPowProvider=class{async pow(e,n){const i=e.slice(0,-8),o=t.Blake2b.sum256(i),r=Yt.calculateTargetZeros(e,n);return Yt.performPow(o,r,"0").toString()}},e.MAX_FUNDS_COUNT=127,e.MAX_INPUT_COUNT=128,e.MAX_MESSAGE_LENGTH=Ut,e.MAX_NUMBER_PARENTS=_t,e.MAX_OUTPUT_COUNT=128,e.MERKLE_PROOF_LENGTH=l,e.MESSAGE_ID_LENGTH=d,e.METADATA_FEATURE_BLOCK_TYPE=2,e.MILESTONE_PAYLOAD_TYPE=1,e.MIN_ADDRESS_LENGTH=w,e.MIN_ADDRESS_UNLOCK_CONDITION_LENGTH=de,e.MIN_ALIAS_ADDRESS_LENGTH=21,e.MIN_ALIAS_OUTPUT_LENGTH=45,e.MIN_ALIAS_UNLOCK_BLOCK_LENGTH=3,e.MIN_BASIC_OUTPUT_LENGTH=12,e.MIN_BLS_ADDRESS_LENGTH=33,e.MIN_DUST_DEPOSIT_RETURN_UNLOCK_CONDITION_LENGTH=ce,e.MIN_ED25519_ADDRESS_LENGTH=m,e.MIN_ED25519_SIGNATURE_LENGTH=it,e.MIN_EXPIRATION_UNLOCK_CONDITION_LENGTH=fe,e.MIN_FEATURE_BLOCKS_LENGTH=1,e.MIN_FEATURE_BLOCK_LENGTH=M,e.MIN_FOUNDRY_OUTPUT_LENGTH=94,e.MIN_GOVERNOR_ADDRESS_UNLOCK_CONDITION_LENGTH=Ue,e.MIN_IMMUTABLE_ALIAS_UNLOCK_CONDITION_LENGTH=ye,e.MIN_INPUT_COUNT=1,e.MIN_INPUT_LENGTH=V,e.MIN_ISSUER_FEATURE_BLOCK_LENGTH=_,e.MIN_METADATA_FEATURE_BLOCK_LENGTH=5,e.MIN_MIGRATED_FUNDS_LENGTH=H,e.MIN_NFT_ADDRESS_LENGTH=21,e.MIN_NFT_OUTPUT_LENGTH=33,e.MIN_NFT_UNLOCK_BLOCK_LENGTH=3,e.MIN_NUMBER_PARENTS=kt,e.MIN_OUTPUT_COUNT=1,e.MIN_OUTPUT_LENGTH=We,e.MIN_PAYLOAD_LENGTH=Tt,e.MIN_REFERENCE_UNLOCK_BLOCK_LENGTH=3,e.MIN_SENDER_FEATURE_BLOCK_LENGTH=x,e.MIN_SIGNATURE_LENGTH=st,e.MIN_SIGNATURE_UNLOCK_BLOCK_LENGTH=ut,e.MIN_SIMPLE_TOKEN_SCHEME_LENGTH=1,e.MIN_STATE_CONTROLLER_ADDRESS_UNLOCK_CONDITION_LENGTH=$e,e.MIN_TAG_FEATURE_BLOCK_LENGTH=2,e.MIN_TIMELOCK_UNLOCK_CONDITION_LENGTH=9,e.MIN_TOKEN_SCHEME_LENGTH=1,e.MIN_TRANSACTION_ESSENCE_LENGTH=je,e.MIN_TREASURY_INPUT_LENGTH=G,e.MIN_TREASURY_OUTPUT_LENGTH=9,e.MIN_UNLOCK_BLOCK_LENGTH=ht,e.MIN_UNLOCK_CONDITIONS_LENGTH=1,e.MIN_UNLOCK_CONDITION_LENGTH=xe,e.MIN_UTXO_INPUT_LENGTH=q,e.NFT_ADDRESS_LENGTH=20,e.NFT_ADDRESS_TYPE=a,e.NFT_ID_LENGTH=20,e.NFT_OUTPUT_TYPE=6,e.NFT_UNLOCK_BLOCK_TYPE=3,e.PowHelper=Yt,e.RECEIPT_PAYLOAD_TYPE=3,e.REFERENCE_UNLOCK_BLOCK_TYPE=1,e.SENDER_FEATURE_BLOCK_TYPE=0,e.SIGNATURE_UNLOCK_BLOCK_TYPE=0,e.SIMPLE_TOKEN_SCHEME_TYPE=0,e.SMALL_TYPE_LENGTH=1,e.STATE_CONTROLLER_ADDRESS_UNLOCK_CONDITION_TYPE=4,e.STRING_LENGTH=2,e.SingleNodeClient=At,e.TAGGED_DATA_PAYLOAD_TYPE=5,e.TAG_FEATURE_BLOCK_TYPE=3,e.TAIL_HASH_LENGTH=49,e.TIMELOCK_UNLOCK_CONDITION_TYPE=2,e.TRANSACTION_ESSENCE_TYPE=0,e.TRANSACTION_ID_LENGTH=u,e.TRANSACTION_PAYLOAD_TYPE=0,e.TREASURY_INPUT_TYPE=1,e.TREASURY_OUTPUT_TYPE=2,e.TREASURY_TRANSACTION_PAYLOAD_TYPE=4,e.TYPE_LENGTH=4,e.UINT16_SIZE=2,e.UINT256_SIZE=32,e.UINT32_SIZE=4,e.UINT64_SIZE=8,e.UINT8_SIZE=1,e.UTXO_INPUT_TYPE=0,e.UnitsHelper=mn,e.buildTransactionPayload=bt,e.calculateAddressBalance=Ot,e.calculateInputs=Gt,e.deserializeAddress=E,e.deserializeAddressUnlockCondition=ue,e.deserializeAliasAddress=c,e.deserializeAliasOutput=Me,e.deserializeAliasUnlockBlock=function(e){if(!e.hasRemaining(3))throw new Error(`Alias Unlock Block data is ${e.length()} in length which is less than the minimimum size required of 3`);const t=e.readUInt8("aliasUnlockBlock.type");if(2!==t)throw new Error(`Type mismatch in aliasUnlockBlock ${t}`);return{type:2,reference:e.readUInt16("aliasUnlockBlock.reference")}},e.deserializeBasicOutput=Oe,e.deserializeBlsAddress=p,e.deserializeDustDepositReturnUnlockCondition=he,e.deserializeEd25519Address=g,e.deserializeEd25519Signature=ot,e.deserializeExpirationUnlockCondition=me,e.deserializeFeatureBlock=R,e.deserializeFeatureBlocks=P,e.deserializeFoundryOutput=Fe,e.deserializeFunds=b,e.deserializeGovernorAddressUnlockCondition=_e,e.deserializeImmutableAliasUnlockCondition=Te,e.deserializeInput=j,e.deserializeInputs=X,e.deserializeIssuerFeatureBlock=k,e.deserializeMessage=function(e){if(!e.hasRemaining(Et))throw new Error(`Message data is ${e.length()} in length which is less than the minimimum size required of ${Et}`);const t=e.readUInt8("message.protocolVersion"),n=e.readUInt8("message.numParents"),i=[];for(let t=0;t<n;t++){const n=e.readFixedHex(`message.parentMessageId${t}`,d);i.push(n)}const o=It(e);if(o&&(3===o.type||4===o.type))throw new Error("Messages can not contain receipt or treasury transaction payloads");const r=e.readUInt64("message.nonce"),s=e.unused();if(0!==s)throw new Error(`Message data length ${e.length()} has unused data ${s}`);return{protocolVersion:t,parentMessageIds:i,payload:o,nonce:r.toString(10)}},e.deserializeMetadataFeatureBlock=N,e.deserializeMigratedFunds=F,e.deserializeNftAddress=T,e.deserializeNftOutput=Ge,e.deserializeNftUnlockBlock=function(e){if(!e.hasRemaining(3))throw new Error(`Nft Unlock Block data is ${e.length()} in length which is less than the minimimum size required of 3`);const t=e.readUInt8("nftUnlockBlock.type");if(3!==t)throw new Error(`Type mismatch in nftUnlockBlock ${t}`);return{type:3,reference:e.readUInt16("nftUnlockBlock.reference")}},e.deserializeOutput=Xe,e.deserializeOutputs=Ze,e.deserializePayload=It,e.deserializeReferenceUnlockBlock=tt,e.deserializeSenderFeatureBlock=v,e.deserializeSignature=at,e.deserializeSignatureUnlockBlock=lt,e.deserializeSimpleTokenScheme=ze,e.deserializeStateControllerAddressUnlockCondition=Ne,e.deserializeTagFeatureBlock=C,e.deserializeTimelockUnlockCondition=we,e.deserializeTokenScheme=be,e.deserializeTransactionEssence=Qe,e.deserializeTreasuryInput=K,e.deserializeTreasuryOutput=Ye,e.deserializeUTXOInput=W,e.deserializeUnlockBlock=mt,e.deserializeUnlockBlocks=pt,e.deserializeUnlockCondition=Ce,e.deserializeUnlockConditions=ve,e.generateBip44Address=Ct,e.generateBip44Path=function(e,n,i){const o=new t.Bip32Path(St);return o.pushHardened(e),o.pushHardened(i?1:0),o.pushHardened(n),o},e.getBalance=async function(e,t,n,i){const o=await Mt(e,t,n,i);let r=0;for(const e of o)r+=e.balance;return r},e.getUnspentAddress=async function(e,t,n,i){const o=await Mt(e,t,n,{startIndex:null==i?void 0:i.startIndex,zeroCount:null==i?void 0:i.zeroCount,requiredCount:1});return o.length>0?o[0]:void 0},e.getUnspentAddresses=Mt,e.getUnspentAddressesWithAddressGenerator=Pt,e.logAddress=tn,e.logFeatureBlock=hn,e.logFeatureBlocks=ln,e.logFunds=an,e.logImmutableFeatureBlocks=cn,e.logInfo=function(e,t){Zt(`${e}\tName:`,t.name),Zt(`${e}\tVersion:`,t.version),Zt(`${e}\t\tStatus`),Zt(`${e}\t\t\tIs Healthy:`,t.status.isHealthy),Zt(`${e}\t\t\tLatest Milestone Index:`,t.status.latestMilestoneIndex),Zt(`${e}\t\t\tLatest Milestone Timestamp:`,t.status.latestMilestoneTimestamp),Zt(`${e}\t\t\tConfirmed Milestone Index:`,t.status.confirmedMilestoneIndex),Zt(`${e}\t\t\tPruning Index:`,t.status.pruningIndex),Zt(`${e}\t\tProtocol`),Zt(`${e}\t\t\tNetwork Name:`,t.protocol.networkName),Zt(`${e}\t\t\tBech32 HRP:`,t.protocol.bech32HRP),Zt(`${e}\t\t\tMin PoW Score:`,t.protocol.minPoWScore),Zt(`${e}\t\t\tRent`),Zt(`${e}\t\t\t\tVByte Cost:`,t.protocol.rentStructure.vByteCost),Zt(`${e}\t\t\t\tVByte Factor Data:`,t.protocol.rentStructure.vByteFactorData),Zt(`${e}\t\t\t\tVByte Factor Key:`,t.protocol.rentStructure.vByteFactorKey),Zt(`${e}\t\tMetrics`),Zt(`${e}\t\t\tMessages Per Second:`,t.metrics.messagesPerSecond),Zt(`${e}\t\t\tReferenced Messages Per Second:`,t.metrics.referencedMessagesPerSecond),Zt(`${e}\t\t\tReferenced Rate:`,t.metrics.referencedRate),Zt(`${e}\tFeatures:`,t.features),Zt(`${e}\tPlugins:`,t.plugins)},e.logInput=on,e.logMessage=function(e,t){if(Zt(`${e}\tProtocol Version:`,t.protocolVersion),t.parentMessageIds)for(let n=0;n<t.parentMessageIds.length;n++)Zt(`${e}\tParent ${n+1} Message Id:`,t.parentMessageIds[n]);Vt(`${e}\t`,t.payload),void 0!==t.nonce&&Zt(`${e}\tNonce:`,t.nonce)},e.logMessageMetadata=function(e,t){if(Zt(`${e}\tMessage Id:`,t.messageId),t.parentMessageIds)for(let n=0;n<t.parentMessageIds.length;n++)Zt(`${e}\tParent ${n+1} Message Id:`,t.parentMessageIds[n]);void 0!==t.isSolid&&Zt(`${e}\tIs Solid:`,t.isSolid),void 0!==t.milestoneIndex&&Zt(`${e}\tMilestone Index:`,t.milestoneIndex),void 0!==t.referencedByMilestoneIndex&&Zt(`${e}\tReferenced By Milestone Index:`,t.referencedByMilestoneIndex),Zt(`${e}\tLedger Inclusion State:`,t.ledgerInclusionState),void 0!==t.conflictReason&&Zt(`${e}\tConflict Reason:`,t.conflictReason),void 0!==t.shouldPromote&&Zt(`${e}\tShould Promote:`,t.shouldPromote),void 0!==t.shouldReattach&&Zt(`${e}\tShould Reattach:`,t.shouldReattach)},e.logMilestonePayload=jt,e.logNativeTokens=dn,e.logOutput=rn,e.logPayload=Vt,e.logReceiptPayload=Qt,e.logSignature=nn,e.logTaggedDataPayload=Jt,e.logTips=function(e,t){if(t.tipMessageIds)for(let n=0;n<t.tipMessageIds.length;n++)Zt(`${e}\tTip ${n+1} Message Id:`,t.tipMessageIds[n])},e.logTokenScheme=un,e.logTransactionPayload=Xt,e.logTreasuryTransactionPayload=en,e.logUnlockBlock=sn,e.logUnlockCondition=fn,e.logUnlockConditions=pn,e.promote=Rt,e.reattach=zt,e.retrieveData=async function(e,t){const n="string"==typeof e?new At(e):e,o=await n.message(t);if(null==o?void 0:o.payload){let e;if(0===o.payload.type?e=o.payload.essence.payload:5===o.payload.type&&(e=o.payload),e)return{tag:i.Converter.hexToBytes(e.tag),data:e.data?i.Converter.hexToBytes(e.data):void 0}}},e.retry=async function(e,t){const n="string"==typeof e?new At(e):e,i=await n.messageMetadata(t);if(!i)throw new Error("The message does not exist.");if(i.shouldPromote)return Rt(e,t);if(i.shouldReattach)return zt(e,t);throw new Error("The message should not be promoted or reattached.")},e.send=async function(e,t,n,i,o,r,s){return Lt(e,t,n,[{addressBech32:i,amount:o}],r,s)},e.sendAdvanced=Ht,e.sendData=async function(e,t,n){const o="string"==typeof e?new At(e):e,r="string"==typeof t?i.Converter.utf8ToHex(t):i.Converter.bytesToHex(t);if(r.length/2<1)throw new Error(`The tag length is ${r.length/2}, which is less than the minimum size of 1`);if(r.length/2>ne)throw new Error(`The tag length is ${r.length/2}, which exceeds the maximum size of 64`);const s={payload:{type:5,tag:r,data:n?"string"==typeof n?i.Converter.utf8ToHex(n):i.Converter.bytesToHex(n):void 0}};return{message:s,messageId:await o.messageSubmit(s)}},e.sendEd25519=async function(e,t,n,i,o,r,s){return Ft(e,t,n,[{addressEd25519:i,amount:o}],r,s)},e.sendMultiple=Lt,e.sendMultipleEd25519=Ft,e.sendWithAddressGenerator=Dt,e.serializeAddress=U,e.serializeAddressUnlockCondition=le,e.serializeAliasAddress=h,e.serializeAliasOutput=Pe,e.serializeAliasUnlockBlock=function(e,t){e.writeUInt8("aliasUnlockBlock.type",t.type),e.writeUInt16("aliasUnlockBlock.reference",t.reference)},e.serializeBasicOutput=Re,e.serializeBlsAddress=f,e.serializeDustDepositReturnUnlockCondition=pe,e.serializeEd25519Address=y,e.serializeEd25519Signature=rt,e.serializeExpirationUnlockCondition=ge,e.serializeFeatureBlock=z,e.serializeFeatureBlocks=O,e.serializeFoundryOutput=De,e.serializeFunds=L,e.serializeGovernorAddressUnlockCondition=ke,e.serializeImmutableAliasUnlockCondition=Ie,e.serializeInput=Q,e.serializeInputs=J,e.serializeIssuerFeatureBlock=$,e.serializeMessage=$t,e.serializeMetadataFeatureBlock=A,e.serializeMigratedFunds=D,e.serializeNftAddress=I,e.serializeNftOutput=Ke,e.serializeNftUnlockBlock=function(e,t){e.writeUInt8("nftUnlockBlock.type",t.type),e.writeUInt16("nftUnlockBlock.reference",t.reference)},e.serializeOutput=Je,e.serializeOutputs=Ve,e.serializePayload=wt,e.serializeReferenceUnlockBlock=nt,e.serializeSenderFeatureBlock=S,e.serializeSignature=dt,e.serializeSignatureUnlockBlock=ct,e.serializeSimpleTokenScheme=He,e.serializeStateControllerAddressUnlockCondition=Ae,e.serializeTagFeatureBlock=B,e.serializeTimelockUnlockCondition=Ee,e.serializeTokenScheme=Le,e.serializeTransactionEssence=et,e.serializeTreasuryInput=Y,e.serializeTreasuryOutput=qe,e.serializeUTXOInput=Z,e.serializeUnlockBlock=gt,e.serializeUnlockBlocks=ft,e.serializeUnlockCondition=Be,e.serializeUnlockConditions=Se,e.setLogger=function(e){Zt=e},Object.defineProperty(e,"__esModule",{value:!0})}));